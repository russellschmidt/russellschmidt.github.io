webpackJsonp([49803254702623],{601:function(e,o){e.exports={data:{markdownRemark:{html:'<p>A little innocuous method <code>method_missing</code> snuck into a problem in my Bloc Software Engineering homework. Oh you know, just implement <code>method_missing</code> for a find() method in our ActiveRecord-ish ORM experiment. I was referred to <a href="http://rubylearning.com/satishtalim/ruby_method_missing.html">this link</a> which is a nice, concise explanation.</p>\n<p>Saving you the click, basically the <code>method_missing</code> method is designed to deal with the <code>NoMethodError</code> exception that is raised when code calls a method that can\'t be found. Our <code>method_missing</code> function allows for a graceful exception handling and potential recovery. In my problem set, I am supposed to implement this such that <code>Entry.find_by(:name, name)</code> and <code>Entry.find_by_name(name)</code> produce identical results.</p>\n<p>A lovely example was presented but as is often the case, the example code is too simple for my tiny, dinosaur brain. I actually need to hop into IRB to understand it.</p>\n<p>So let\'s play around in console.</p>\n<pre><code class="language-bash">2.3.0 :013 > class Person\n2.3.0 :014?>   def hey\n2.3.0 :015?>     puts "hey"\n2.3.0 :016?>     end\n2.3.0 :017?>   def bye\n2.3.0 :018?>     puts "bye"\n2.3.0 :019?>     end\n2.3.0 :020?>   def method_missing(m, *args, &#x26;block)\n2.3.0 :021?>     puts "no #{m} here"\n2.3.0 :022?>     end\n2.3.0 :023?>   end\n\n2.3.0 :024 > bob = Person.new\n => #&#x3C;Person:0x007fb6c9a7b8e0>\n\n2.3.0 :027 > bob.fcks_given\nno fcks_given here\n => nil\n</code></pre>\n<p> So this is the basic idea - we call a method that is not defined in the class, and we get a nice graceful message.</p>\n<p> But I am supposed to be able to make a method <code>Entry.find_by_name(name)</code> fire off. Now note that only <code>find_by</code> exists in code. Naturally I need to do a bit more research to figure out the best approach for a solution.</p>\n<p> Fortunately, I have bought a dozen Ruby books, and the gem of a book Eloquent Ruby has an entire chapter devoted to <code>method_missing</code>.</p>\n<p> The first thing to know is that <code>method_missing</code> is pure Ruby magic. When a function is called and is not found in the inheritance tree, the party does not just stop. Ruby then calls <code>method_missing</code> secretly in the background. What we do when we implement <code>method_missing</code> is we are overriding the default behavior. That is important to know if we are going to be customizing the method, because you definitely some sort of default behavior for non-explicit cases.</p>\n<p> Now I think I figured this out for the quick\'n\'dirty solution, being sure to define in the same class as my <code>find_by</code> method:</p>\n<pre><code class="language-ruby"> def method_missing(method, *arguments, &#x26;block)\n   if method == "find_by_name"\n     find_by(:name, *arguments)\n   else\n     puts "no such method found"\n   end\n end\n</code></pre>\n<p>So we can satisfy the problem set\'s solution and see how this method can serve to provide your own syntactic sugar within your code - such as providing custom method names for search, here - without repeating method definitions.</p>\n<p>Per my amazing book on Eloquent Ruby, there is even more that you can do with <code>method_missing</code> besides customizing an already robust error catching method. You can also use <code>method_missing</code> for delegation.</p>\n<p>Let\'s say we have a class <code>Spreadsheet</code> and we also have a class <code>SecretSpreadsheet</code> that needs to authenticate the user attempting to view a <code>Spreadsheet</code> before handing off control. If <code>Spreadsheet</code> has 25 methods, we would need to write 25 methods in <code>SecretSpreadsheet</code> that first authenticate and then lastly pass off to the same-named method in <code>Spreadsheet</code> which is repetitive and lame. It does not scale well as a solution at all - every new method on <code>Spreadsheet</code> needs an analog method in <code>SecretSpreadsheet</code>.</p>\n<p>So the solution is to use <code>method_missing</code> as a catch-all that will authenticate and then use our new best friend method <code>send</code> to call the method. This is an exceptional use case for <code>send</code> as obviously we can\'t call a method in the form of a variable in the syntax <code>@spreadsheet.variable_name</code> - we need to use <code>variable.send(method, *arguments)</code> and then we don\'t need to write 25 methods in <code>SecretSpreadsheet</code> - we only write what we need for the security routines and then pass the method and arguments onto our original <code>Spreadsheet</code> class. The trick is <code>send</code> allows us to call functions dynamically and programmatically.</p>\n<p>What happens if a super common method like <code>to_s</code> is called on a <code>SecretSpreadsheet</code> object? It will never hit <code>method_missing</code> because it isn\'t missing! The book suggests you have your <code>SecretSpreadsheet</code> document inherit from <code>BasicObject</code> which is such a foundational, atomic class that it practically has no methods, which avoids all this trouble. Now even common methods will be unknown and trip the <code>method_missing</code>.</p>',frontmatter:{date:"October 17, 2016",path:"/blog/ruby-method-missing/",title:"Ruby Method Mising",type:"blog"}}},pathContext:{}}}});
//# sourceMappingURL=path---blog-ruby-method-missing-9df3a79b10a7ffd50f06.js.map